<!doctype html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<title>Keybase: Keys for everyone! Part II - chrislaing.net</title>
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="generator" content="Hugo 0.101.0" /><meta property="og:site_name" content="chrislaing.net">
  <meta property="og:title" content="Keybase: Keys for everyone! Part II">
  <meta property="og:description" content="chrislaing.net">
  <meta property="description" content="chrislaing.net">
  <meta property="og:url" content="http://chrislaing.net/blog/keybase-keys-for-everyone-part-ii/">
  <meta property="og:type" content="article">
  
    <meta property="og:image" content="http://chrislaing.net/img/main/wading_small.png">
  
  <link rel="stylesheet" href="/css/bundle.min.6ad9eb85bff384c75937a02036b01425a2ca63f19a96535b8ba5b181db62a4b3.css" integrity="sha256-atnrhb/zhMdZN6AgNrAUJaLKY/GallNbi6WxgdtipLM="><link rel="stylesheet" href="/css/add-on.css">
</head>

  <body>
    

<header id="site-header">
  <nav id="site-nav">
    <h1 class="nav-title">
      <a href="/" class="nav">
        
          Blog
        
      </a>
    </h1>
    <menu id="site-nav-menu" class="flyout-menu menu">
      
        
          
          <a href="/" class="nav link"><i class='fa fa-home'></i> Home</a>
        
      
        
          
          <a href="/about" class="nav link"><i class='far fa-id-card'></i> About</a>
        
      
        
          
          <a href="/blog" class="nav link"><i class='far fa-newspaper'></i> Blog</a>
        
      
        
          
          <a href="/categories" class="nav link"><i class='fas fa-sitemap'></i> Categories</a>
        
      
      <a href="#share-menu" class="nav link share-toggle"><i class="fas fa-share-alt">&nbsp;</i>Share</a>
      <a href="#search-input" class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a>
    </menu>
    <a href="#search-input" class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
    <a href="#share-menu" class="nav share-toggle"><i class="fas fa-share-alt fa-2x">&nbsp;</i></a>
    <a href="#lang-menu" class="nav lang-toggle" lang="en">en</a>
    <a href="#site-nav" class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a>
  </nav>
  <menu id="search" class="menu"><input id="search-input" class="search-input menu"></input><div id="search-results" class="search-results menu"></div></menu>
  <menu id="lang-menu" class="flyout-menu menu">
  <a href="#" lang="en" class="nav link active"> (en)</a>
  
    
      
    
  
</menu>

  
    <menu id="share-menu" class="flyout-menu menu">
      <h1>Share Post</h1>
      




  
    
    <a href="//twitter.com/share?text=Keybase%3a%20Keys%20for%20everyone%21%20Part%20II&amp;url=http%3a%2f%2fchrislaing.net%2fblog%2fkeybase-keys-for-everyone-part-ii%2f" target="_blank" rel="noopener" class="nav share-btn twitter">
        <p>Twitter</p>
      </a>
  

  
    <a href="//www.reddit.com/submit?url=http%3a%2f%2fchrislaing.net%2fblog%2fkeybase-keys-for-everyone-part-ii%2f&amp;title=Keybase%3a%20Keys%20for%20everyone%21%20Part%20II" target="_blank" rel="noopener" class="nav share-btn reddit">
          <p>Reddit</p>
        </a>
  

  
        <a href="//www.linkedin.com/shareArticle?url=http%3a%2f%2fchrislaing.net%2fblog%2fkeybase-keys-for-everyone-part-ii%2f&amp;title=Keybase%3a%20Keys%20for%20everyone%21%20Part%20II" target="_blank" rel="noopener" class="nav share-btn linkedin">
            <p>LinkedIn</p>
          </a>
  

  
        <a href="mailto:?subject=Check%20out%20this%20post%20by Christopher%20Laing&amp;body=http%3a%2f%2fchrislaing.net%2fblog%2fkeybase-keys-for-everyone-part-ii%2f" target="_blank" class="nav share-btn email" data-proofer-ignore>
          <p>Email</p>
        </a>
  


    </menu>
  
</header>

    <div id="wrapper">
      <section id="site-intro" >
  <a href="/"><img src="http://chrislaing.net/img/main/wading_small.png" class="circle" width="100" alt="chrislaing.net" /></a>
  <header>
    <h1>chrislaing.net</h1>
  </header>
  <main>
    <p>Beware the Mathematician</p>
  </main>
  
    <footer>
      <ul class="socnet-icons">
        

        











<li><a href="//www.linkedin.com/in/christopherlaing" target="_blank" rel="noopener" title="LinkedIn" class="fab fa-linkedin"></a></li>















<li><a href="//twitter.com/cjlaing" target="_blank" rel="noopener" title="Twitter" class="fab fa-twitter"></a></li>










<li><a href="//mastodon.sdf.org/@laingc" target="_blank" rel="noopener" title="mastodon" class="fab fa-mastodon"></a></li>


      </ul>
    </footer>
  
</section>

      <main id="site-main">
        
  <article>
    <div class="post">
      <header>
  <div class="title">
    
      <h2><a href="/blog/keybase-keys-for-everyone-part-ii/">Keybase: Keys for everyone! Part II</a></h2>
    
    
  </div>
  <div class="meta">
    <time datetime="2017-02-20 00:00:00 &#43;0000 UTC">February 20, 2017</time>
    <p>Christopher Laing</p>
    <p>11-Minute Read</p>
  </div>
</header>

      <div id="socnet-share">
        




  
    
    <a href="//twitter.com/share?text=Keybase%3a%20Keys%20for%20everyone%21%20Part%20II&amp;url=http%3a%2f%2fchrislaing.net%2fblog%2fkeybase-keys-for-everyone-part-ii%2f" target="_blank" rel="noopener" class="nav share-btn twitter">
        <p>Twitter</p>
      </a>
  

  
    <a href="//www.reddit.com/submit?url=http%3a%2f%2fchrislaing.net%2fblog%2fkeybase-keys-for-everyone-part-ii%2f&amp;title=Keybase%3a%20Keys%20for%20everyone%21%20Part%20II" target="_blank" rel="noopener" class="nav share-btn reddit">
          <p>Reddit</p>
        </a>
  

  
        <a href="//www.linkedin.com/shareArticle?url=http%3a%2f%2fchrislaing.net%2fblog%2fkeybase-keys-for-everyone-part-ii%2f&amp;title=Keybase%3a%20Keys%20for%20everyone%21%20Part%20II" target="_blank" rel="noopener" class="nav share-btn linkedin">
            <p>LinkedIn</p>
          </a>
  

  
        <a href="mailto:?subject=Check%20out%20this%20post%20by Christopher%20Laing&amp;body=http%3a%2f%2fchrislaing.net%2fblog%2fkeybase-keys-for-everyone-part-ii%2f" target="_blank" class="nav share-btn email" data-proofer-ignore>
          <p>Email</p>
        </a>
  


      </div>
      <div class="content">
        
        <p>In a <a href="http://chrislaing.net/blog/keybase-keys-for-everyone-part-i/">previous post</a>, we discussed <a href="https://keybase.io">Keybase</a>, a clever company that is solving a lot of the classic problems that users have had with PGP: managing keys, verifying identities, trusting third parties, and user experience.</p>
<p>I also mentioned that Keybase insures iteself against an attack on its servers by writing the root of its Merkle tree into the blockchain. In this post, we&rsquo;ll explore what this means, and go through the process of verifying this ourselves step-by-step.</p>
<p>Before we rush ahead to the verification, let&rsquo;s take a moment to understand what a Merkle root is, and why Keybase is using them.</p>
<p>Suppose that we have some discrete blocks of data, and that we would like to be able to verify the integrity of these data. Concretely, let&rsquo;s suppose that every time I do something on Keybase, such as verify myself on some social media account or revoke a device key, Keybase creates a JSON file which describes this activity, and stores this on its servers. Another user of Keybase can then go to Keybase&rsquo;s servers and collect this JSON blob from them, in order to verify my public activity. To be even more precise, the data that the other user really wants is my signature chain; a cryptographically signed chain that records my activity.</p>
<p>However, there&rsquo;s a problem. Servers are notoriously hackable, and if someone were to compromise Keybase&rsquo;s server, I could be downloading a JSON file that is telling me any old lies. Now, a compromised server&rsquo;s ability to lie is dramatically restricted by the fact that any user can verify the signature chain themselves, checking external social media sites for the claimed proofs. However, a compromised server would be able to show different versions of the server state to different users.</p>
<p>This is where the Merkle tree enters the equation. A Merkle tree takes each of the pieces of data we would like to verify, the &ldquo;leaves&rdquo; of the tree, and hashes them. Several of these hashes are then collected together according to a defined algorithm, and the concatenation of them is then itself hashed. These concatenations are then also grouped and hashed, and so on. This heirarchical grouping forms a tree, with each concatenated hash forming a node of the tree. Eventually, we end up with one final, concatenated hash. This hash is the root of the tree. Once in possession of the root hash and the algorithm used to group and concatenate the hashes, we can verify the state of every single leaf node at the point in time that they were hashed, giving us a picture of a consistent server state. All that is needed now is for us to be able to trust the root hash of the Merkle tree, which is achieved by signing the root hash with a private key.</p>
<p>The utility of a Merkle tree for keybase now becomes obvious. This system is, however, potentially vulnerable to a sophisticated &ldquo;forking&rdquo; attack. One example of such an attack might be that I revoke a compromised key, and publish this change to the comprimised Keybase server. The attacker chooses not to present an updated version of the Merkle tree to another user, and exploits his lack of knowledge of my published revokation.</p>
<p>Keybase solves this problem by writing the root of the Merkle tree to the Bitcoin blockchain by sending bitcoins from a known address to another. Instead of using the bitcoins, Keybase is using 160 bits of the receiving address to encode the root hash of the Merkle tree. To be a little more precise, Keybase generates a Merkle tree, then signs the root hash of the tree with its private key. It then generates a 160-bit hash of this signature, and sends Bitcoins from their address to the address represented by this hash. Once we know the address receiving the Bitcoins, we can compare the root hash of the Merkle tree presented to us by Keybase&rsquo;s servers to that stored in the blockchain, rendering the forking attack useless.</p>
<figure><img src="/img/2016/11/Hash_Tree.png"
         alt="from:https://en.wikipedia.org/wiki/Merkle_tree"/>
</figure>

<p>Let&rsquo;s go through this process step by step, pausing where appropriate to make sure that we really understand what&rsquo;s going on. We&rsquo;ll use Python 3.5 to do this, partly because it is my language of choice for most tasks, but mostly because the <a href="https://keybase.io/docs/server_security/merkle_root_in_bitcoin_blockchain">original keybase security documentation</a> uses Python, albeit version 2.7. Let me be clear right from the outset that the code is taken almost entirely from the keybase security documentation, and credit for it should be attributed to the Keybase team. My contribution is limited to making the code work with Python 3.5, and a few cosmetic edits for legibility.</p>
<p>We start by importing the packages that we&rsquo;ll need.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> requests<span style="color:#f92672">,</span> datetime<span style="color:#f92672">,</span> json<span style="color:#f92672">,</span> re<span style="color:#f92672">,</span> gnupg
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> base64 <span style="color:#f92672">import</span> b64decode
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pycoin.encoding <span style="color:#f92672">import</span> bitcoin_address_to_hash160_sec, hash160
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> binascii <span style="color:#f92672">import</span> hexlify
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> hashlib <span style="color:#f92672">import</span> sha512, sha256
</span></span></code></pre></div><p>Recall that what we need to find is the 160-bit hash of the signed root of the Keybase Merkle tree, which is stored in the blockchain as the receiving address for the latest transaction from the sending address <code>1HUCBSJeHnkhzrVKVjaVmWg2QtZS1mdfaz</code>. Without downloading the multi-gigabyte Bitcoin blockchain in its entirity, the easiest way to find this address is to query <a href="https://blockchain.info">blockchain.info</a> using the requests library. Requests is a beautifully written python library, that is often cited as the gold standard for clean, pythonic APIs. I recommend learning to use its basic functionality even for simple cases such as ours.</p>
<p>We use a simple GET request to query the blockchain.info API.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>from_addr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1HUCBSJeHnkhzrVKVjaVmWg2QtZS1mdfaz&#34;</span>
</span></span><span style="display:flex;"><span>uri       <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://blockchain.info/address/</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">?format=json&#34;</span> <span style="color:#f92672">%</span> (from_addr)
</span></span><span style="display:flex;"><span>r <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(uri)
</span></span><span style="display:flex;"><span>to_addr   <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>json()[<span style="color:#e6db74">&#39;txs&#39;</span>][<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#39;out&#39;</span>][<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#39;addr&#39;</span>]
</span></span><span style="display:flex;"><span>to_addr_hash <span style="color:#f92672">=</span> hexlify(bitcoin_address_to_hash160_sec(to_addr))<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>print(to_addr_hash)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>1eeea91d88d3578e3e718fa97da8ec79d7227304
</span></span></code></pre></div><p>Notice that we have decoded the string from UTF-8. We will see this decoding and encoding of strings to and from UTF-8 appears several times as we progress. The difference from the keybase.io example arises because of the different way that Python 3.5 handles strings, and the encoding expectations of the different libraries that we are using.</p>
<p>Given that our code varies from that presented on keybase.io, it would be reasonable to ask whether this encoding and decoding in some way invalidates the verification that we are undertaking. These processes merely alter the representation of the string, not its content. It is not the string object as it appears in computer memory that we are verifying, but the evaluated content of the string. Theoretically, we could even perform the verification process by hand, separating the content of the string entirely from its representation in computer memory. We are therefore on farily safe ground.</p>
<p>The variable <code>to_addr_hash</code> now contains a hexadecimal hash, which corresponds to a root block on the Keybase servers. We can query the Keybase API to find that block.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>kb        <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://keybase.io/_/api/1.0&#34;</span>
</span></span><span style="display:flex;"><span>uri       <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">/merkle/root.json?hash160=</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (kb, to_addr_hash)
</span></span><span style="display:flex;"><span>r <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(uri)
</span></span><span style="display:flex;"><span>root_desc <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(r<span style="color:#f92672">.</span>text)
</span></span></code></pre></div><p>The <code>root_desc</code> variable now holds a JSON file full of information about the root block. What we need is the signature of the hash of the root block, which is contained in the <code>sig</code> field. Noting again the string encoding and decoding, we use a regular expression to extract the signature itself from the surrounding ASCII armouring, and verify with an assert statement that the hexadecimal hash of the signature matches the hexadecimal hash of the receiving bitcoin address that we found in the first step.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>sig <span style="color:#f92672">=</span> b64decode(re<span style="color:#f92672">.</span>compile(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;\n\n((\S|\n)*?)\n=&#34;</span>)<span style="color:#f92672">.</span>search(root_desc[<span style="color:#e6db74">&#39;sig&#39;</span>])<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>, <span style="color:#e6db74">&#39;ignore&#39;</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> to_addr_hash <span style="color:#f92672">==</span> hexlify(hash160(sig))<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>, <span style="color:#e6db74">&#39;ignore&#39;</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;We have the correct block.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Oops, wrong block!&#34;</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>We have the correct block.
</span></span></code></pre></div><p>Recall that this hash is not the root hash itself. Rather, it is the 160-bit hash of the Keybase PGP signature of the root hash. This makes sense, as we would like to be sure not just that the Merkle tree is intact, but that Keybase has verified it as being correct.</p>
<p>Keybase&rsquo;s Merkle key has the fingerprint <code>03E146CDAF8136680AD566912A32340CEC8C9492</code>, and is imported into my GPG keyring. The gnupg python package allows us to inspect this signature and verify it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gpg <span style="color:#f92672">=</span> gnupg<span style="color:#f92672">.</span>GPG()
</span></span><span style="display:flex;"><span>verified <span style="color:#f92672">=</span> gpg<span style="color:#f92672">.</span>verify(sig)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;Signed by </span><span style="color:#e6db74">{0}</span><span style="color:#e6db74">,</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74"> with public key fingerprint </span><span style="color:#e6db74">{1}</span><span style="color:#e6db74">,</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74"> on </span><span style="color:#e6db74">{2}</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>format(verified<span style="color:#f92672">.</span>username, 
</span></span><span style="display:flex;"><span>                                                                                  verified<span style="color:#f92672">.</span>pubkey_fingerprint,
</span></span><span style="display:flex;"><span>                                                                                 datetime<span style="color:#f92672">.</span>datetime<span style="color:#f92672">.</span>utcfromtimestamp(
</span></span><span style="display:flex;"><span>                                                                                float(verified<span style="color:#f92672">.</span>sig_timestamp))
</span></span><span style="display:flex;"><span>                                                                                  <span style="color:#f92672">.</span>strftime(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">/%m/%Y&#39;</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> verified<span style="color:#f92672">.</span>valid:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Signature is valid.&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Signature invalid!&#39;</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Signed by Keybase.io Merkle Signing (v1) &lt;merkle@keybase.io&gt;,
</span></span><span style="display:flex;"><span> with public key fingerprint 03E146CDAF8136680AD566912A32340CEC8C9492,
</span></span><span style="display:flex;"><span> on 20/02/2017.
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>Signature is valid.
</span></span></code></pre></div><p>Now we know that not only is the Merkle tree is intact, but that Keybase has verified it as being correct, and when they did so. The signature object contains the root hash of the root block of the Merkle tree. We can use another regular expression to find it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>root_hash <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(re<span style="color:#f92672">.</span>compile(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;({[\x00-\x7f]*})&#34;</span>)<span style="color:#f92672">.</span>search(sig<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>, <span style="color:#e6db74">&#39;ignore&#39;</span>))<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">1</span>))[<span style="color:#e6db74">&#39;body&#39;</span>][<span style="color:#e6db74">&#39;root&#39;</span>]
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;Root block hash: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> root_hash)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Root block hash: 55a8731fdb7141f0e8441d01f0431624de9d275952e7dcb19bb35088a0e5cf90312c67cb0fc876a5a888b61fa545c1261bc2732ac2d759e6f9488b30ff902f28
</span></span></code></pre></div><p>Now that we have the hash of the root block, let&rsquo;s check that the Keybase server wasn&rsquo;t lying to us about the contents of the block.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>uri <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">/merkle/block.json?hash=</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (kb, root_hash)
</span></span><span style="display:flex;"><span>value_string <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(uri)<span style="color:#f92672">.</span>json()[<span style="color:#e6db74">&#39;value_string&#39;</span>]
</span></span><span style="display:flex;"><span>computed_hash <span style="color:#f92672">=</span> hexlify(sha512(value_string<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>))<span style="color:#f92672">.</span>digest())<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> computed_hash <span style="color:#f92672">==</span> root_hash:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Root hash and computed hash match.&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Root hash: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">,</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">%</span>root_hash, <span style="color:#e6db74">&#39;Computed hash: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">%</span>computed_hash)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Root hash and computed hash match.
</span></span></code></pre></div><p>Let&rsquo;s pause and think about what we&rsquo;ve discovered. We know that Keybase created a Merkle tree, which encodes the exact status of every user&rsquo;s signature chain at the time that the tree was written. The root hash of this tree was then signed by Keybase, and then this signature was hashed and written into the blockchain.</p>
<p>To verify this, we walked backwards through the process. We went to the blockchain and found the latest hash, and asked Keybase for the signed Merkle tree corresponding to this hash. We verified that the hash of this signature corresponded to the hash that we found in the blockchain, and then verified that the signature came from Keybase. Having done that, we checked that the hash we were given is correct by computing the hash ourselves, and comparing the two.</p>
<p>We can now descend the Merkle tree to find the last thing I signed into my sigchain. You can use any user, as this is public information (indeed, that&rsquo;s the point!), so try your own.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>username <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;chrislaing&#34;</span>
</span></span><span style="display:flex;"><span>uri      <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">/user/lookup.json?username=</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (kb, username)
</span></span><span style="display:flex;"><span>r <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(uri)
</span></span><span style="display:flex;"><span>uid <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>json()[<span style="color:#e6db74">&#39;them&#39;</span>][<span style="color:#e6db74">&#39;id&#39;</span>]
</span></span></code></pre></div><p>Let&rsquo;s define a couple of helper functions to make descending the tree easier. The trees are written in such a way that the JSON string returned by the API has as keys the first few characters of the hash. The method I use in <code>traverse_tree</code> is actually quite ugly, as it simply checks each potential key length until it finds a match. The data is so small, however, that I didn&rsquo;t see the need to write a prettier way of doing it - if you&rsquo;d like to do this, then please leave a comment, and I&rsquo;ll update the post.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">traverse_tree</span>(start_hash):
</span></span><span style="display:flex;"><span>    uri <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">/merkle/block.json?hash=</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (kb, start_hash)
</span></span><span style="display:flex;"><span>    value_string <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(uri)<span style="color:#f92672">.</span>json()[<span style="color:#e6db74">&#39;value_string&#39;</span>]
</span></span><span style="display:flex;"><span>    computed_hash <span style="color:#f92672">=</span> hexlify(sha512(value_string<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>))<span style="color:#f92672">.</span>digest())<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span>(computed_hash <span style="color:#f92672">==</span> start_hash)
</span></span><span style="display:flex;"><span>    tab <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(value_string)[<span style="color:#e6db74">&#39;tab&#39;</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(uid)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> uid[:i] <span style="color:#f92672">in</span> tab<span style="color:#f92672">.</span>keys():
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#39;key length </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> of </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">%</span>(i, len(uid)))
</span></span><span style="display:flex;"><span>            nxt <span style="color:#f92672">=</span> tab[uid[:i]]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> len(uid):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> nxt[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> nxt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">verify_link_hash</span>(link_hash):
</span></span><span style="display:flex;"><span>    uri <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">/sig/get.json?uid=</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (kb, uid)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(uri)<span style="color:#f92672">.</span>json()[<span style="color:#e6db74">&#39;sigs&#39;</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#e6db74">&#39;payload_json&#39;</span>]
</span></span><span style="display:flex;"><span>    computed_hash <span style="color:#f92672">=</span> hexlify(sha256(payload<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>))<span style="color:#f92672">.</span>digest())<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (computed_hash <span style="color:#f92672">==</span> link_hash<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_computed_hash</span>(uid):
</span></span><span style="display:flex;"><span>    uri <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">/sig/get.json?uid=</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (kb, uid)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(uri)<span style="color:#f92672">.</span>json()[<span style="color:#e6db74">&#39;sigs&#39;</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#e6db74">&#39;payload_json&#39;</span>]
</span></span><span style="display:flex;"><span>    computed_hash <span style="color:#f92672">=</span> hexlify(sha256(payload<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>))<span style="color:#f92672">.</span>digest())<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> computed_hash
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_payload</span>(uid):
</span></span><span style="display:flex;"><span>    uri <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">/sig/get.json?uid=</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (kb, uid)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(uri)<span style="color:#f92672">.</span>json()[<span style="color:#e6db74">&#39;sigs&#39;</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#e6db74">&#39;payload_json&#39;</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload        
</span></span></code></pre></div><p>The idea is very simple. Using my user ID, we query the Keybase api for the last action that I signed into my sigchain. To verify that this exists in the version of the Merkle tree that we verified above, we walk down the Merkle tree, progressively querying the Keybase API for each new node, and then comparing the hash of what Keybase tells us to the hash we expect. In this way, we verify all the contents of the Merkle tree from the root, down the branches that lead to my leaf, until we arrive at my leaf block itself.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>link_hash <span style="color:#f92672">=</span> root_hash
</span></span><span style="display:flex;"><span>computed_hash <span style="color:#f92672">=</span> get_computed_hash(uid)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> link_hash <span style="color:#f92672">!=</span> computed_hash:
</span></span><span style="display:flex;"><span>    link_hash <span style="color:#f92672">=</span> traverse_tree(link_hash)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> link_hash <span style="color:#f92672">==</span> computed_hash:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Leaf node found in the Merkle tree.&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Leaf node is not part of the Merkle tree!&#39;</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>key length 1 of 32
</span></span><span style="display:flex;"><span>key length 2 of 32
</span></span><span style="display:flex;"><span>key length 3 of 32
</span></span><span style="display:flex;"><span>key length 4 of 32
</span></span><span style="display:flex;"><span>key length 32 of 32
</span></span><span style="display:flex;"><span>Leaf node found in the Merkle tree.
</span></span></code></pre></div><p>Now that we know that the server state that Keybase is reporting to us is correct, consistent, and signed by Keybase, we can inspect the payload we got from the API to see what I actually did.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>json<span style="color:#f92672">.</span>loads(get_payload(uid))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>   &#39;body&#39;:{  
</span></span><span style="display:flex;"><span>      &#39;key&#39;:{  
</span></span><span style="display:flex;"><span>         &#39;eldest_kid&#39;:&#39;0101c0eab8dc42e80f0a754adc7d5504249ca3dc2d6c848407e6e148729c800a25010a&#39;,
</span></span><span style="display:flex;"><span>         &#39;host&#39;:&#39;keybase.io&#39;,
</span></span><span style="display:flex;"><span>         &#39;kid&#39;:&#39;0120d945e916db5015ff9e8d5605e822e3808c90602a043fe08aa43b91449a5de6b40a&#39;,
</span></span><span style="display:flex;"><span>         &#39;uid&#39;:&#39;4ac28b770f9cd1199981621a42eac000&#39;,
</span></span><span style="display:flex;"><span>         &#39;username&#39;:&#39;chrislaing&#39;
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      &#39;service&#39;:{  
</span></span><span style="display:flex;"><span>         &#39;name&#39;:&#39;reddit&#39;,
</span></span><span style="display:flex;"><span>         &#39;username&#39;:&#39;laing_c&#39;
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      &#39;type&#39;:&#39;web_service_binding&#39;,
</span></span><span style="display:flex;"><span>      &#39;version&#39;:1
</span></span><span style="display:flex;"><span>   },
</span></span><span style="display:flex;"><span>   &#39;client&#39;:{  
</span></span><span style="display:flex;"><span>      &#39;name&#39;:&#39;keybase.io go client&#39;,
</span></span><span style="display:flex;"><span>      &#39;version&#39;:&#39;1.0.18&#39;
</span></span><span style="display:flex;"><span>   },
</span></span><span style="display:flex;"><span>   &#39;ctime&#39;:1487579548,
</span></span><span style="display:flex;"><span>   &#39;expire_in&#39;:504576000,
</span></span><span style="display:flex;"><span>   &#39;merkle_root&#39;:{  
</span></span><span style="display:flex;"><span>      &#39;ctime&#39;:1487579413,
</span></span><span style="display:flex;"><span>      &#39;hash&#39;:&#39;f37e1e249b16110bb5ad4fdaba7cc044ee86ce6aae1efb1c51eedf6ca9d955a6cd400e19dc9211e68ad9cf74a4b2082aa767c831ff625417a936e82b6d6857fd&#39;,
</span></span><span style="display:flex;"><span>      &#39;seqno&#39;:907120
</span></span><span style="display:flex;"><span>   },
</span></span><span style="display:flex;"><span>   &#39;prev&#39;:&#39;bf84e1e3dd41765dd105ee814bc4b81dcba6a3988f5c12896b56ab2d430ecb9b&#39;,
</span></span><span style="display:flex;"><span>   &#39;seqno&#39;:45,
</span></span><span style="display:flex;"><span>   &#39;tag&#39;:&#39;signature&#39;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this case, I proved my reddit identity, <code>laing_c</code>. The JSON blob also contains lots of useful details about the proof, such as the time that I signed it, the details of the client used to sign the proof, and so on.</p>
<p>In case you&rsquo;re curious, <a href="https://www.reddit.com/r/KeybaseProofs/comments/5v3hy8/my_keybase_proof_redditlaing_c_keybasechrislaing/">here&rsquo;s the proof.</a></p>
<figure><img src="/img/2016/11/reddit_keybase_proof.png"
         alt="My Keybase proof on Reddit"/>
</figure>

<p>Now we know how to verify that Keybase hasn&rsquo;t been taken over by a malicious third party, who is seeking to lie to us - either actively or by omission - about the state of the Keybase server.</p>
<p>I really applaud the team at Keybase for going to this extent. It&rsquo;s fantastic that they have managed to combine a very accessible day-to-day user experience with a completely open and verifiable trust system. I haven&rsquo;t even touched on some of the other magic they&rsquo;ve been working, such as the <a href="https://keybase.io/docs/kbfs">Keybase file system</a>, but I might come to that in a future post.</p>
<p>I hope that you enjoyed this little walk through the Keybase blockchain verification system, and that you found it somewhat helpful in understanding how Keybase works.</p>
      </div>
      <footer>
        <div class="stats">
  
    <ul class="categories">
      
        
          <li><a class="article-terms-link" href="/categories/cryptography/">cryptography</a></li>
        
          <li><a class="article-terms-link" href="/categories/technology/">technology</a></li>
        
      
    </ul>
  
  
    <ul class="tags">
      <li>None</li>
    </ul>
  
</div>

      </footer>
    </div>
    
      

    
  </article>
  <div class="pagination">
    
      <a href="/blog/odds-and-ends-1/" class="button left"><span>Odds and Ends #1</span></a>
    
    
      <a href="/blog/keybase-keys-for-everyone-part-i/" class="button right"><span>Keybase: Keys for everyone! Part I</span></a>
    
  </div>

      </main>
      <section id="site-sidebar">
  
    <section id="recent-posts">
      <header>
        <h1>Recent Posts</h1>
      </header>
      
      <article class="mini-post">
          <a href="/blog/high-code/" class="image" style="--bg-image: url('http://chrislaing.net/img/2024/08/high-code.jpg');">
    <img class="stretchV" src="http://chrislaing.net/img/2024/08/high-code.jpg" alt="High-Code: The Unexpected Path to AI Democratisation">
  </a>
        <header>
          <h2><a href="/blog/high-code/">High-Code: The Unexpected Path to AI Democratisation</a></h2>
          <time class="published" datetime="2024-08-01 15:00:00 &#43;1300 &#43;1300">August 1, 2024</time>
        </header>
      </article>
      
      <article class="mini-post">
          <a href="/blog/the-economics-and-ergonomics-of-ai/" class="image" style="--bg-image: url('http://chrislaing.net/img/2024/07/llm-economics.webp');">
    <img class="stretchV" src="http://chrislaing.net/img/2024/07/llm-economics.webp" alt="Large Language Model Economics">
  </a>
        <header>
          <h2><a href="/blog/the-economics-and-ergonomics-of-ai/">On the Economics and Ergonomics of LLMs</a></h2>
          <time class="published" datetime="2024-07-16 10:00:00 &#43;1300 &#43;1300">July 16, 2024</time>
        </header>
      </article>
      
      <article class="mini-post">
          <a href="/blog/decomposition-of-llms/" class="image" style="--bg-image: url('http://chrislaing.net/img/2023/05/circuit.jpeg');">
    <img class="stretchV" src="http://chrislaing.net/img/2023/05/circuit.jpeg" alt="a circuitboard">
  </a>
        <header>
          <h2><a href="/blog/decomposition-of-llms/">The Decomposition of Large Language Models</a></h2>
          <time class="published" datetime="2023-05-30 09:00:00 &#43;1300 &#43;1300">May 30, 2023</time>
        </header>
      </article>
      
      <article class="mini-post">
          <a href="/blog/the-large-language-model-iceberg/" class="image" style="--bg-image: url('http://chrislaing.net/img/2023/04/iceberg.jpg');">
    <img class="stretchV" src="http://chrislaing.net/img/2023/04/iceberg.jpg" alt="The Large Language Model Iceberg">
  </a>
        <header>
          <h2><a href="/blog/the-large-language-model-iceberg/">The Large Language Model Iceberg</a></h2>
          <time class="published" datetime="2023-04-01 13:30:00 &#43;1300 &#43;1300">April 1, 2023</time>
        </header>
      </article>
      
      <article class="mini-post">
          <a href="/blog/three-categories-of-ai/" class="image" style="--bg-image: url('http://chrislaing.net/img/2021/07/three-types-of-ai.jpg');">
    <img class="stretchV" src="http://chrislaing.net/img/2021/07/three-types-of-ai.jpg" alt="">
  </a>
        <header>
          <h2><a href="/blog/three-categories-of-ai/">Three Categories of AI</a></h2>
          <time class="published" datetime="2021-07-25 19:00:00 &#43;1300 &#43;1300">July 25, 2021</time>
        </header>
      </article>
      
      
        <footer>
          <a href="/blog" class="button">See More</a>
        </footer>
      
    </section>
  

  
    

      <section id="categories">
        <header>
          <h1><a href="/categories">Categories</a></h1>
        </header>
        <ul>
          
          
          <li>
              <a href="/categories/technology/">technology<span class="count">15</span></a>
          
          <li>
              <a href="/categories/business/">business<span class="count">6</span></a>
          
          <li>
              <a href="/categories/odds-and-ends/">odds-and-ends<span class="count">4</span></a>
          
          <li>
              <a href="/categories/cryptography/">cryptography<span class="count">2</span></a>
          
          <li>
              <a href="/categories/podcasts/">podcasts<span class="count">1</span></a>
          
          </li>
        </ul>
      </section>
    
  

  
    <section id="mini-bio">
      <header>
        <h1>About</h1>
      </header>
      <p>The personal website of Christopher Laing.</p>
      <footer>
        <a href="/about" class="button">Learn More</a>
      </footer>
    </section>
  
</section>

      <footer id="site-footer">
  
      <ul class="socnet-icons">
        

        











<li><a href="//www.linkedin.com/in/christopherlaing" target="_blank" rel="noopener" title="LinkedIn" class="fab fa-linkedin"></a></li>















<li><a href="//twitter.com/cjlaing" target="_blank" rel="noopener" title="Twitter" class="fab fa-twitter"></a></li>










<li><a href="//mastodon.sdf.org/@laingc" target="_blank" rel="noopener" title="mastodon" class="fab fa-mastodon"></a></li>


      </ul>
  
  <p class="copyright">
    © 2024 chrislaing.net
      <br>
    Theme: <a href='https://github.com/pacollins/hugo-future-imperfect-slim' target='_blank' rel='noopener'>Hugo Future Imperfect Slim</a><br>A <a href='https://html5up.net/future-imperfect' target='_blank' rel='noopener'>HTML5 UP port</a> | Powered by <a href='https://gohugo.io/' title='0.101.0' target='_blank' rel='noopener'>Hugo</a>
  </p>
</footer>
<a id="back-to-top" href="#" class="fas fa-arrow-up fa-2x"></a>

      <script src="/js/highlight.js"></script>
    
    <script>hljs.highlightAll();</script><script src="/js/bundle.min.9c9aa1e70420ece57e60b30ee9e8965e296a6eedb9646aea30f1bc470b660902.js" integrity="sha256-nJqh5wQg7OV&#43;YLMO6eiWXilqbu25ZGrqMPG8RwtmCQI="></script>
    <script src="/js/add-on.js"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-91338724-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    </div>
  </body>
</html>
